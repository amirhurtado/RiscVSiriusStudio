/* eslint-disable @typescript-eslint/naming-convention */

import {
  getFunct3,
  getFunct7,
  isIArithmetic,
  isILoad,
  isIJump,
  isAUIPC,
  isILogical,
  getImmFunct7,
} from "../../utilities/instructions";

/**
 * Defines the shape of the control signals generated by the ControlUnit.
 */
export interface ControlSignals {
  ru_wr: boolean; // Enable writing to the Register Unit
  alua_src: boolean; // MUX selector for ALU's A input (false=rs1, true=PC)
  alub_src: boolean; // MUX selector for ALU's B input (false=rs2, true=Immediate)
  dm_wr: boolean; // Enable writing to Data Memory
  ru_data_wr_src: string; // MUX selector for data to write back ('00': ALU, '01': Mem, '10': PC+4)
  alu_op: string; // Operation code for the ALU
  br_op: string; // Operation code for the Branch Unit
  imm_src: string;
}

/**
 * Simulates the Control Unit. Generates all control signals based on the instruction.
 */
export class ControlUnit {
  public generate(instruction: any): ControlSignals {
    const type = instruction.type;
    const opcode = instruction.opcode;

    let signals: ControlSignals = {
      ru_wr: false,
      alua_src: false,
      alub_src: false,
      dm_wr: false,
      ru_data_wr_src: "00",
      alu_op: "00000",
      br_op: "00XXX",
      imm_src: "X",
    };

    switch (type) {
      case "R":
        const funct7 = getFunct7(instruction);
        signals.ru_wr = true;
        signals.alu_op = funct7[6] + funct7[1] + getFunct3(instruction);
        break;

      case "I":
        signals.ru_wr = true;
        signals.alub_src = true;
        signals.imm_src = "000";


        if (isIArithmetic(type, opcode)) {
          const MSBaluOp = isILogical(instruction.instruction)
            ? getImmFunct7(instruction.encoding.imm12)[1]!
            : "0";
          signals.alu_op = "0" + MSBaluOp + getFunct3(instruction);
        } else if (isILoad(type, opcode)) {
          signals.alu_op = "00000";
          signals.ru_data_wr_src = "01";
        } else if (isIJump(type, opcode)) {
          signals.alu_op = "00000";
          signals.ru_data_wr_src = "10";
          signals.br_op = "1XXXX";
        }
        break;

      case "S":
        signals.alub_src = true;
        signals.dm_wr = true;
        signals.alu_op = "00000";
        signals.imm_src = "001";
        break;

      case "B":
        signals.alua_src = true;
        signals.alub_src = true;
        signals.br_op = "01" + getFunct3(instruction);
        signals.imm_src = "101";
        break;

      case "U":
        signals.ru_wr = true;
        signals.alub_src = true;
        signals.alu_op = "00000";
        if (isAUIPC(type, opcode)) {
          signals.alua_src = true;
        }
        signals.imm_src = "010";

        break;

      case "J":
        signals.ru_wr = true;
        signals.alua_src = true;
        signals.alub_src = true;
        signals.ru_data_wr_src = "10";
        signals.alu_op = "00000";
        signals.br_op = "1XXXX";
        signals.imm_src = "110";

        break;
    }
    return signals;
  }
}

/**
 * Simulates the Immediate Unit. Generates the sign-extended immediate value.
 * This logic is a direct 1:1 extraction from the original SCCPU's execute methods.
 */
export class ImmediateUnit {
  public generate(instruction: any): string {
    const type = instruction.type;
    const encoding = instruction.encoding;
    let imm: string;

    switch (type) {
      case "I":
        imm = encoding.imm12 || "0";
        // Special case for I-type logical instructions, extracted from executeIInstruction
        if (isILogical(instruction.instruction)) {
          let immAsArray = imm.padStart(32, imm.charAt(0)).split("");
          immAsArray[21] = "0";
          return immAsArray.join("");
        }
        break;
      case "S":
        // The parser provides imm12 for S-type from imm7 and imm5
        imm = encoding.imm12 || "0";
        break;
      case "B":
        imm = encoding.imm13 || "0";
        break;
      case "U":
        imm = encoding.imm21 || "0";
        // U-type uses padEnd, not padStart, for LUI/AUIPC
        return imm.padEnd(32, "0");
      case "J":
        imm = encoding.imm21 || "0";
        break;
      default:
        imm = "0";
    }
    // Default sign-extension for I, S, B, J types
    return imm.padStart(32, imm.charAt(0));
  }
}
