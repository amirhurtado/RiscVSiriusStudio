{{
  var instcounter = 0;
  var instEncoding = {};
  let labelTable = {}
/* Support functions */

  function getInstMemPosition() {
    const memIndex = instcounter * 4;
    instcounter = instcounter + 1;
    //console.log("mem ", memIndex);
    return memIndex;
  }

  function extractList(list, index) {
    return list.map(function(element) { return element[index]; });
  }

  function buildList(head, tail, index) {

    return [head].concat(extractList(tail, index));
  }
  function getInt(val) { return parseInt(val,10); }
  function isImm12(val) { return val >= -2048 && val <= 2047; }
  function isImm13(val) { return val >= -4096 && val <= 4095; }
  function isImm21(val) { return val >= -1048576 && val <= 1048575; }
  function isImm32(val) { return val >= 0 && val <= 4294967295; }
  function isValidShift(val) { return val >= 0 && val < 32; }
  function isILogical(name) {
    return (name == 'slli'|| name == 'srli' || name == 'srai');
  }
  
  function toRadix (value, radix) {
    if (!Number.isSafeInteger(value)) {
      throw new TypeError('value must be a safe integer');
    }
    
    const digits = Math.ceil(64 / Math.log2(radix));
    const twosComplement = value < 0 ? BigInt(radix) ** BigInt(digits) + BigInt(value) : value;
    return twosComplement.toString(radix).padStart(digits, '0');
  }
  
  function toBinaryString(value, bitlength) {
    return toRadix(value,2).slice(bitlength * -1);
  }
  
  function encodingAsHex(binenc) {
    let hexEncoding = binenc.replace(/-/g,"");
    let groups4 = hexEncoding.match(/.{1,8}/g);
    
    let enc = groups4.map(
            (b8) => {
                  let hex = parseInt(b8,2).toString(16).toUpperCase();
                              let padHex = hex.padStart(2,"0");
                    //return l.reduce((acc, c) => { return acc.concat(c);},"");
                            return padHex;
                          }
            );
      return enc.toString().replace(/,/g,"-");
  }

  function regEnc(r) {
    return { regname: 'x'+r, regeq: 'x'+r, regenc: r}; 
  }

  function handleRInstruction(name, rd, rs1, rs2, location, pseudo=false) {
    var funct3;
    var funct7;
    switch (name) {
      case 'add'  : funct3 = 0; funct7 = 0;  break;
      case 'sub'  : funct3 = 0; funct7 = 32; /* 32 = 0x20 */  break;
      case 'xor'  : funct3 = 4; funct7 = 0;  break;
      case 'or'   : funct3 = 6; funct7 = 0;  break;
      case 'and'  : funct3 = 7; funct7 = 0;  break;
      case 'sll'  : funct3 = 1; funct7 = 0;  break;
      case 'srl'  : funct3 = 5; funct7 = 0;  break;
      case 'sra'  : funct3 = 5; funct7 = 32; /* 32 = 0x20 */  break;
      case 'slt'  : funct3 = 2; funct7 = 0;  break;
      case 'sltu' : funct3 = 3; funct7 = 0;  break;
    }
    const rdVal = getInt(rd["regenc"]);
    const rdBin = toBinaryString(rdVal,5);
    
    const funct3Bin = toBinaryString(funct3,3);
    const rs1Val = getInt(rs1["regenc"]);
    const rs1Bin = toBinaryString(rs1Val,5);
    
    const rs2Val = getInt(rs2["regenc"]);
    const rs2Bin = toBinaryString(rs2Val,5);
    const funct7Bin = toBinaryString(funct7,7);
    const opcode = "0110011";
    
    const binEncoding = 
      `${funct7Bin}${rs2Bin}${rs1Bin}${funct3Bin}${rdBin}${opcode}`;
    
    const encoding = {
      "binEncoding": binEncoding, "funct3": funct3Bin, "rs1": rs1Bin, 
      "rs2": rs2Bin, "rd": rdBin, "funct7": funct7Bin
    };
    
    return {
      "inst":getInstMemPosition(), "type":"R", "instruction": name, "rd":rd, 
      "rs1":rs1, "rs2": rs2, "funct3": funct3, "funct7": funct7, 
      "opcode": opcode, "encoding": encoding, "location":location, 
      "pseudo":pseudo
    };
    
  }

  function handleIInstruction(name, rd, rs1, imm, location, pseudo=false) {
    if (isILogical(name) && !isValidShift(imm)) {
      return error("Expecting valid shift ammount. Got " + imm);
    }
    
    let funct3  = 0;
    let funct7  = 0;
    let opcode = '0010011';
    let isLoad  = false;
    let isJalr  = false;
    let isEcall = false;

    switch (name) {
      case 'addi'  : funct3 = 0; break;
      case 'xori'  : funct3 = 4; break;
      case 'ori'   : funct3 = 6; break;
      case 'andi'  : funct3 = 7; break;
      case 'slli'  : funct3 = 1; funct7 = 0;  break;
      case 'srli'  : funct3 = 5; funct7 = 0;  break;
      case 'srai'  : funct3 = 3; funct7 = 32;  /* 32 = 0x20 */ break;
      case 'slti'  : funct3 = 2; break;
      case 'sltiu' : funct3 = 3; break;

      // Load instructions
      case 'lb'  : {funct3 = 0; isLoad = true; } break;
      case 'lh'  : {funct3 = 1; isLoad = true; } break;
      case 'lw'  : {funct3 = 2; isLoad = true; } break;
      case 'lbu' : {funct3 = 4; isLoad = true; } break;
      case 'lhu' : {funct3 = 5; isLoad = true; } break;

      // Jalr instruction
      case 'jalr': {funct3 = 0; isJalr = true; opcode = '1100111'; } break;

      // Ecall and ebreak instructions
      case 'ecall' : {funct3 = 0; isJalr = true; opcode = '1110011'; } break;
      case 'ebreak': {funct3 = 0; isJalr = true; opcode = '1110011'; } break;
    }
    
    if (isLoad) {
      opcode = "0000011"; 
    } 

    const rdVal = getInt(rd["regenc"]);
    const rdBin = toBinaryString(rdVal,5);

    const funct3Bin = toBinaryString(funct3,3);

    const rs1Val = getInt(rs1["regenc"]);
    const rs1Bin = toBinaryString(rs1Val,5);

    const immVal = getInt(imm);
    const immValBin = toBinaryString(immVal,12);

    const binEncoding = `${immValBin}${rs1Bin}${funct3Bin}${rdBin}${opcode}`;

    const encoding = {
      "rd": rdBin, "funct3": funct3Bin, "rs1": rs1Bin, "imm12":immValBin, 
      "binEncoding": binEncoding
    };

    return {
      "inst":getInstMemPosition(), "type":"i", "instruction": name, "rd":rd,
      "rs1":rs1, "imm12": imm, "funct3": funct3,  "opcode": opcode,
      "encoding":encoding, "location":location, "pseudo":pseudo
    };
  }

  function handleSInstruction(name, rs2, offset, rs1, location) {
    var funct3;
    switch (name) {
      case 'sb'  : funct3 = 0; break;
      case 'sh'  : funct3 = 1; break;
      case 'sw'  : funct3 = 2; break;
    }
    const rs1Val = getInt(rs1["regenc"]);
    const rs1Bin = toBinaryString(rs1Val,5);
    
    const rs2Val = getInt(rs2["regenc"]);
    const rs2Bin = toBinaryString(rs2Val,5);

    const funct3Bin = toBinaryString(funct3,3);
      
    const immVal = getInt(offset);
    const immValBin = toBinaryString(immVal,12);
      
    const imm11_5 = immValBin.substring(0,7);
    const imm4_0 = immValBin.substring(7);

    const binEncoding = `${imm11_5}${rs2Bin}${rs1Bin}${funct3Bin}${imm4_0}0100011`;

    const encoding = {
      "funct3": funct3Bin, "rs1": rs1Bin, "rs2": rs2Bin, "imm12":immValBin,
      "binEncoding": binEncoding,
    };

    return {
      "inst":getInstMemPosition(), "type":"s", "instruction": name, "rs1":rs1, 
      "rs2":rs2, "imm12": offset, "funct3": funct3,  "opcode": "0100011", 
      "encoding":encoding, "location":location
    };
  }

  function handleBInstruction(name, rs1, rs2, target, location, pseudo=false) {
    const instMem = getInstMemPosition();
    let funct3;
    switch (name) {
      case 'beq'   : funct3 = 0; break;
      case 'bne'   : funct3 = 1; break;
      case 'blt'   : funct3 = 4; break;
      case 'bge'   : funct3 = 5; break;
      case 'bltu'  : funct3 = 6; break;
      case 'bgeu'  : funct3 = 7; break;
    }
      
    const rs1Val = getInt(rs1["regenc"]);
    const rs1Bin = toBinaryString(rs1Val,5);
      
    const rs2Val = getInt(rs2["regenc"]);
    const rs2Bin = toBinaryString(rs2Val,5);

    const funct3Bin = toBinaryString(funct3,3);
    
    console.log("handleBInstruction", target);

    const tgtVal = getInt(target);
    const immVal = tgtVal - instMem;
    const immValBin = toBinaryString(immVal,13);

    const imm12 = immValBin.substring(0,1);
    const imm11 = immValBin.substring(1,2); 
    const imm10_5 = immValBin.substring(2,8); 
    const imm4_1 = immValBin.substring(8,12); 

    const funct7 = `${imm12}${imm10_5}`;
    const rd = `${imm4_1}${imm11}`;
      
    const encoding = {
      "binEncoding": `${funct7}${rs2Bin}${rs1Bin}${funct3Bin}${rd}1100011`,
      "imm[12]": imm12, "imm[10:5]":imm10_5, "imm[4:1]":imm4_1, "imm[11]":imm11,
      "funct3": funct3Bin, "funct7": funct7, "imm13":immValBin
    };

    return {
      "inst":instMem, "type":"b", "instruction": name, "rs1":rs1,
      "rs2":rs2, "imm13": target, "funct3": funct3, "opcode": "1100011", 
      "encoding":encoding, "location":location, "pseudoInst": pseudo
    };
  }

  function handleJInstruction(name, rd, target, location, pseudo=false) {
    const rdVal = getInt(rd["regenc"]);
    const rdBin = toBinaryString(rdVal,5);
    const instMem = getInstMemPosition();

    console.log("handleJInstruction", target);
    const tgtVal = getInt(target);
    const immVal = tgtVal - instMem;
    const immValBin = toBinaryString(immVal,21);
      
    const imm20 = immValBin.substring(0,1);
    const imm11 = immValBin.substring(9,10); 
    const imm19_12 = immValBin.substring(1,9); 
    const imm10_1 = immValBin.substring(10,20); 

    const binEncoding = `${imm20}${imm10_1}${imm11}${imm19_12}${rdBin}1101111`;

    const encoding = {
      "imm21":immVal, "rd":rd,  "binEncoding": binEncoding, "imm[20]": imm20,
      "imm[11]": imm11, "imm[19:12]":imm19_12, "imm[10:1]":imm10_1, 
      "tgtVal": tgtVal
    };

    return {
      "inst":instMem, "type":"j", "instruction": name,
      "imm21": target, "opcode": "1101111", "encoding":encoding,
      "location":location, "pseudo":pseudo
    };
  }

  function handleUInstruction(name, rd, offset, location, pseudo=false) {
    let opcode = null;
    if (name == "lui") { opcode = "0110111"; } else { opcode = "0010111"; }

    const rdVal = getInt(rd["regenc"]);
    const rdBin = toBinaryString(rdVal,5);

    const immVal = getInt(offset);
    const immValBin = toBinaryString(immVal,21).substring(1,22);
      
    const binEncoding = `${immValBin}-${rdBin}-${opcode}`;

    const encoding = {
      "rd": rdBin, "imm21": immValBin, "binEncoding": binEncoding
    };

    return {
      "inst":getInstMemPosition(), "type":"u", "instruction": name, "rd":rd,
      "imm21": offset, "opcode": opcode, "encoding":encoding, 
      "location":location, "pseudo":pseudo
    };
  }

  function handleBPInstruction(name, rs1, rs2, offset, location) {
    const zeroReg = { regname: 'x0', regeq: 'x0', regenc: '0'};
    if (rs2 == null) {
      let op = null;
      let r1 = null;
      let r2 = null;
      switch (name) {
        case 'beqz': {op = 'beq'; r1 = rs1;     r2 = zeroReg; } break;
        case 'bnez': {op = 'bne'; r1 = rs1;     r2 = zeroReg; } break;
        case 'blez': {op = 'bge'; r1 = zeroReg; r2 = rs1;      } break;
        case 'bgez': {op = 'bge'; r1 = rs1;     r2 = zeroReg; } break;
        case 'bltz': {op = 'blt'; r1 = rs1;     r2 = zeroReg; } break;
        case 'bgtz': {op = 'blt'; r1 = zeroReg; r2 = rs1;     } break;
      }
      return handleBInstruction(op, r1, r2, offset, location, true);
    } else {
      let op = null;
      switch (name) {
        case 'bgt' : op = 'blt';  break;
        case 'ble' : op = 'bge';  break;
        case 'bgtu': op = 'bltu'; break;
        case 'bleu': op = 'bgeu'; break;
      }
      return handleBInstruction(op, rs2, rs1, offset, location, true);
    }
  }
}}

{
  labelTable = options["symbols"];
}

  Start = Program 
  
  Program = root:SourceElements?
  {
    instcounter = 0;
    return root;
  }

  SourceElements = __ head:SourceElement tail:(__ SourceElement)* {
    return buildList(head, tail, 1);
  }

  SourceElement 
  = lbl:LabelDeclaration EOS 
  { 
    let ret = lbl;
    ret["Type"] = "SrcLabel";
    ret["location"] = location();
    return ret;
  }
  / dir:Directive EOS 
  {
    let ret = dir;
    ret["Type"] = "SrcDirective"; 
    ret["location"] = location();
    return dir; 
  }
  / inst:Instruction EOS 
  {

    let ret = inst;
    ret["Type"] = "SrcInstruction";
    const binEncoding = inst["encoding"]["binEncoding"];
    inst["encoding"]["hexEncoding"] = encodingAsHex(binEncoding);
    console.log("Instruction rule", ret);
    return ret; 
  }

  LabelDeclaration
  = id:IdentifierName _ ":"
  {
    // During preparsing the labes were transformed into absolute memory
    // addresses. At this point we only check that everything is ok and every 
    // label we find is already in labelTable

    if (!(id['name'] in labelTable)) {
      console.error("Label not found!");
    }

    return {identifier:id, instruction:instcounter};
  }

  Directive
  = id:DirectiveName _ val:QuotedString
  {
    return {"name":id, "value":{val}};
  }

  Instruction "Instruction"
    = inst:RInstruction 
    {
      inst["asm"] = text();
      return inst;
    }
    / inst:IInstruction
    {
      inst["asm"] = text();
      return inst;
    }
    / inst:LInstruction
    {
      inst["asm"] = text();
      return inst;
    }
    / inst:SInstruction
    {
      inst["asm"] = text();
      return inst;
    }
    / inst:BInstruction
    {
      inst["asm"] = text();
      return inst;
    }
    / inst:JInstruction
    {
      inst["asm"] = text();
      return inst;
    }
    / inst:UInstruction
    {
      inst["asm"] = text();
      return inst;
    }
    / inst:EInstruction
    {
      inst["asm"] = text();
      return inst;
    }
    / inst:PseudoInstruction 
    {
      inst["asm"] = text();
      return inst;
    }
    / a:. .* {
      return error('Expecting a valid instruction, Got:"' + text() +'"');
    }
      
  // Parsing rule for R type instructions
  RInstruction "R-type instruction"
    = name:RInstName _ rd:RegisterName ___ rs1:RegisterName ___ rs2:RegisterName
    { return handleRInstruction(name, rd, rs1, rs2, location()); }
  // Parsing rule for I type instructions
  IInstruction "I-type instruction"
    = name:IInstName _ rd:RegisterName ___ rs1:RegisterName ___ imm:Imm12 
    { return handleIInstruction(name, rd, rs1, imm, location()); }
    / addiToken _ rd:RegisterName ___ rs1:RegisterName ___ imm:AsmModifier
    {
      console.log("Assembler modifier!");
      return handleIInstruction('addi', rd, rs1, imm, location());
    }
  /* Parsing rule for load instructions.
   *
   * They are I instructions but are written in a different format and hence
   * need a different rule.
   */
  LInstruction "Load instruction"
    = name:LoadInstName _ rd:RegisterName ___ offset:Imm12 _"("_ rs1:RegisterName _")" 
    { return handleIInstruction(name, rd, rs1, offset, location()); }
    
  // Parsing rule for store instructions
  SInstruction "Store instruction"
    = name:StoreInstName _ rs2:RegisterName ___ offset:Imm12 _"("_ rs1:RegisterName _")" 
    { return handleSInstruction(name, rs2, offset, rs1, location()); }

  // Parsing rule for branch instructions
  BInstruction "Branch instruction"
    = name:BranchInstName _ rs1:RegisterName ___ rs2:RegisterName ___ target:BTarget
    {  return handleBInstruction(name, rs1, rs2, target, location()); }

  // Parsing rule for jump instructions: jal and jalr
  JInstruction "Jump instruction"
    = name:jalrToken _ rd:RegisterName ___ rs1:RegisterName ___ offset:Imm12 
    { return handleIInstruction(name, rd, rs1, offset, location()); }
    /  name:jalToken _ rd:RegisterName ___ target:JTarget 
    { return handleJInstruction(name, rd, target, location()); }
    
  // Parsing rule for upper immediate instructions
  UInstruction "Upper imm instruction"
    = luiToken _ rd:RegisterName ___  imm:AsmModifier
    {
      console.log("assembler identifier");
      return handleUInstruction('lui', rd, imm, location());
    }
    / name:UpperImmInstName _ rd:RegisterName ___ offset:Imm21 
    { return handleUInstruction(name, rd, offset, location()); }

  EInstruction "E instruction"
    = name:(ecallToken / ebreakToken) 
    {
      const zeroReg = { regname: 'x0', regeq: 'x0', regenc: '0'};
      if (name == 'ecall') {
        return handleIInstruction(name, zeroReg, zeroReg, '0', location());
      } else {
        return handleIInstruction(name, zeroReg, zeroReg, '1', location());
      }
    }

  PseudoInstruction "Pseudo instruction"
    = BPInstruction
    / JPInstruction
    / MiscInstruction

  BPInstruction "Branch pseudo instruction"
    = name:BPZInstName _ rs:RegisterName ___ offset:Imm13 
    { return handleBPInstruction(name, rs, null, offset, location()); }
    / name:BPInstName _ rs1:RegisterName ___ rs2:RegisterName ___ offset:Imm13 
    { return handleBPInstruction(name, rs1, rs2, offset, location()); }
  
  JPInstruction "Jump pseudo instruction"
    = jalrToken _ rs:RegisterName
    {
      return handleIInstruction('jalr', regEnc('1'), rs, '0', location(), true);
    }
    / jalToken _ offset:Imm21
    {
      return handleJInstruction('jal', regEnc('1'), offset, location(), true);
    }
    / jrToken _ rs:RegisterName
    {
      return handleIInstruction('jalr', regEnc('0'), rs, '0', location(), true);
    }
//    / jToken _ offset:Imm21
    / jToken _ target:JTarget
    {
      return handleJInstruction('jal', regEnc('0'), target, location(), true);
    }
    / retToken 
    {
      return handleIInstruction(
        'jalr', regEnc('0'), regEnc('1'), '0', location(), true
      );
    }
    /*
    / name:(callToken / tailToken) _ offset:Imm32
    { 
      const x1Reg = { regname: 'x1', regeq: 'x1', regenc: '1'}; 
      const x6Reg = { regname: 'x6', regeq: 'x6', regenc: '6'}; 
      const x0Reg = { regname: 'x0', regeq: 'x0', regenc: '0'}; 

      const binOffset = toBinaryString(offset,32);
      const h = binOffset.substring(0,20);
      const l = binOffset.substring(20);
      const high = parseInt(h,10);
      const low = parseInt(l,10);

      const auipc = handleUInstruction('auipc', x6Reg, high, location(), true);

      let jalr = null;
      if (name == 'call') {
        jalr = handleIInstruction('jalr', x1Reg, x6Reg, low, location(), true);
      } else {
        jalr = handleIInstruction('jalr', x0Reg, x6Reg, low, location(), true);
      }
      
      return jalr;
    }
    */
    
    MiscInstruction "Misc. instructions"
    = mvToken _ rd:RegisterName ___ rs:RegisterName
    { return handleIInstruction('addi', rd, rs, '0', location(), true); }
    / nopToken 
    { 
      return handleIInstruction(
        'addi', regEnc('0'), regEnc('0'), '0', location(), true
      ); 
    }
    / notToken _ rd:RegisterName ___ rs:RegisterName
    {
      return handleIInstruction('xori', rd, rs, '-1', location(), true); 
    }
    / negToken _ rd:RegisterName ___ rs:RegisterName
    {
      return handleRInstruction('sub', rd, regEnc('0'), rs, location(), true); 
    }
    / seqzToken _ rd:RegisterName ___ rs:RegisterName
    {
      return handleIInstruction('sltiu', rd, rs, '1', location(), true); 
    }
    / snezToken _ rd:RegisterName ___ rs:RegisterName
    {
      return handleRInstruction('sltu', rd, regEnc('0'), rs, location(), true);
    }
    / sltzToken _ rd:RegisterName ___ rs:RegisterName
    { 
      return handleRInstruction('slt', rd, rs, regEnc('0'), location(), true); 
    }
    / sgtzToken _ rd:RegisterName ___ rs:RegisterName
    { 
      return handleRInstruction('slt', rd, regEnc('0'), rs, location(), true); 
    }

  Imm12 "12 bits immediate"
  = val:Integer
    {
      const v = getInt(val);
        if (isImm12(v))
          return v;
        return error("Expecting 12 bit representable value [-2048,2047]. Got " + v, location());
  }

  Imm13 "13 bits immediate"
  = val:Integer
    {
      const v = getInt(val);
        if (isImm13(v))
          return v;
        return error("Expecting 13 bit representable value [-4096, 4095]. Got " + v, location());
  }

  Imm21 "21 bits immediate"
  = val:Integer
  {
      const v = getInt(val);
      if (isImm21(v))
        return v;
      error("Expecting 21 bit representable value [-1048576, 1048575]. Got " + v, location());
  }

  Imm32 "32 bits immediate"
  = val:Integer
    {
      const v = getInt(val);
        if (isImm32(v))
          return v;
        return error("Expecting 32 bit representable value [0, 4294967295]. Got " + v, location());
  }

  JTarget "target address of a jump instruction"
  = imm:Imm21 { return imm; }
  / lbl:Identifier 
  { const label = lbl["name"];
    const pointsTo = labelTable[label];
    const value = pointsTo['memdef'];
    if (isImm21(value)) {
        return value;
    }
    return error("Expecting 21 bit representable value [-1048576, 1048575]. Got " + value); 
  }

  BTarget "target address of a jump instruction"
  = imm:Imm13 { return imm; }
  / lbl:Identifier {
    const label = lbl["name"];
    const pointsTo = labelTable[label];
    const value = pointsTo['memdef'];
    if (isImm13(value)) {
        return value;
    }
    return error("Expecting 13 bit representable value [-4096, 4095]. Got " + v, location());
  }

  AsmModifier "assembler modifier"
  /*
    The behavior of this part is based on the documentation at:
    https://sourceware.org/binutils/docs-2.42/as/RISC_002dV_002dModifiers.html

    TODO: Is there any other source?
  */
  = "%" _ "lo" _ "(" _ lbl:Identifier _ ")"
  {
    /*
        %lo(symbol): The low 12 bits of absolute address for symbol.
    */
    const label = lbl["name"];
    const pointsTo = labelTable[label];
    const value = pointsTo['memdef'];
    const value13 = ((1 << 13) - 1) & value;
    console.log("lo(symbol): ", value, value13,location());
    return value13;
  }
  / "%" _ "hi" _ "(" _ lbl:Identifier _ ")"
  {
    const label = lbl["name"];
    const pointsTo = labelTable[label];
    const value = pointsTo['memdef'];
    const mask = ((1 << 20) - 1) << 12; 
    const value20 = (mask & value) >> 12;
    console.log("hi(symbol): ", value, value20, location());
    return value20;
  }

  JumpInstName "jump instruction"
  = jalToken

  UpperImmInstName "upper immediate instruction"
  = luiToken
  / auipcToken
    
  BranchInstName "branch type instruction name"
  = beqToken
  / bneToken
  / bltToken
  / bgeToken
  / bltuToken
  / bgeuToken
  
  BPZInstName "branch zero pseudo instruction name"
  = beqzToken 
  / bnezToken
  / blezToken
  / bgezToken
  / bltzToken
  / bgtzToken 

  BPInstName "branch pseudo instruction name"
  = bgtuToken
  / bleuToken
  / bgtToken 
  / bleToken

  MiscInstName "misc. pseudo instruction name"
  = nopToken
  / liToken
  / mvToken
  / notToken
  / negToken
  / seqzToken
  / snezToken
  / sltzToken
  / sgtzToken

  StoreInstName "store type instruction name"
  = sbToken
  / shToken
  / swToken

  LoadInstName "load type instruction name"
  = lbToken
  / lhToken
  / lwToken
  / lbuToken
  / lhuToken
    
  RInstName "r-type instruction name"
  = addToken
  / subToken
  / xorToken
  / orToken
  / andToken
  / sllToken
  / srlToken
  / sraToken
  / sltToken
  / sltuToken
  
  IInstName "i-type instruction name"
  = addiToken
  / xoriToken
  / oriToken
  / andiToken
  / slliToken
  / srliToken
  / sraiToken
  / sltiToken
  / sltiuToken
  
  RegisterName "register name" 
  = reg:ABIRegister
  {
    var r = reg;
    r["regenc"] = reg["regeq"].slice(1);
    return r;
  }
  / reg:Register 
  {
    const v = reg.slice(1);
    return {"regname": reg, "regeq": reg, "regenc":v};
  }

  Register "register"
  = x10Token
  / x11Token
  / x12Token
  / x13Token
  / x14Token
  / x15Token
  / x16Token
  / x17Token
  / x18Token
  / x19Token
  / x20Token
  / x21Token
  / x22Token
  / x23Token
  / x24Token
  / x25Token
  / x26Token
  / x27Token
  / x28Token
  / x29Token
  / x30Token
  / x31Token
  / x0Token
  / x1Token
  / x2Token
  / x3Token
  / x4Token
  / x5Token
  / x6Token
  / x7Token
  / x8Token
  / x9Token

  ABIRegister "ABI name for register"
  = reg:ZEROToken {return {"regname": reg, "regeq": "x0"}; }
  / reg:RAToken   {return {"regname": reg, "regeq": "x1"}; }
  / reg:SPToken   {return {"regname": reg, "regeq": "x2"}; }
  / reg:GPToken  {return {"regname": reg, "regeq": "x3"}; } 
  / reg:TPToken  {return {"regname": reg, "regeq": "x4"}; }
  / reg:T0Token  {return {"regname": reg, "regeq": "x5"}; }
  / reg:T1Token  {return {"regname": reg, "regeq": "x6"}; }  
  / reg:T2Token  {return {"regname": reg, "regeq": "x7"}; }  
  / reg:T3Token  {return {"regname": reg, "regeq": "x28"};}  
  / reg:T4Token  {return {"regname": reg, "regeq": "x29"};} 
  / reg:T5Token  {return {"regname": reg, "regeq": "x30"};}  
  / reg:T6Token  {return {"regname": reg, "regeq": "x31"};}  
  / reg:S0Token  {return {"regname": reg, "regeq": "x8"}; }
  / reg:FPToken  {return {"regname": reg, "regeq": "x8"}; }  
  / reg:S1Token  {return {"regname": reg, "regeq": "x9"}; }  
  / reg:S2Token  {return {"regname": reg, "regeq": "x18"};}  
  / reg:S3Token  {return {"regname": reg, "regeq": "x19"};}
  / reg:S4Token  {return {"regname": reg, "regeq": "x20"};} 
  / reg:S5Token  {return {"regname": reg, "regeq": "x21"};} 
  / reg:S6Token  {return {"regname": reg, "regeq": "x22"};} 
  / reg:S7Token  {return {"regname": reg, "regeq": "x23"};} 
  / reg:S8Token  {return {"regname": reg, "regeq": "x24"};} 
  / reg:S9Token  {return {"regname": reg, "regeq": "x25"};} 
  / reg:S10Token {return {"regname": reg, "regeq": "x26"};} 
  / reg:S11Token {return {"regname": reg, "regeq": "x27"};} 
  / reg:A0Token  {return {"regname": reg, "regeq": "x10"};} 
  / reg:A1Token  {return {"regname": reg, "regeq": "x11"};} 
  / reg:A2Token  {return {"regname": reg, "regeq": "x12"};} 
  / reg:A3Token  {return {"regname": reg, "regeq": "x13"};} 
  / reg:A4Token  {return {"regname": reg, "regeq": "x14"};} 
  / reg:A5Token  {return {"regname": reg, "regeq": "x15"};} 
  / reg:A6Token  {return {"regname": reg, "regeq": "x16"};} 
  / reg:A7Token  {return {"regname": reg, "regeq": "x17"};} 
    
  addToken  = "add"
  subToken  = "sub"
  xorToken  = "xor"
  orToken   = "or"
  andToken  = "and"
  sllToken  = "sll"
  srlToken  = "srl"
  sraToken  = "sra"
  sltToken  = "slt"
  sltuToken = "sltu"
  
  addiToken  = "addi"
  xoriToken  = "xori"
  oriToken   = "ori"
  andiToken  = "andi"
  slliToken  = "slli"
  srliToken  = "srli"
  sraiToken  = "srai"
  sltiToken  = "slti"
  sltiuToken = "sltiu"
  
  lbToken  = "lb"
  lhToken  = "lh"
  lwToken  = "lw"
  lbuToken = "lbu"
  lhuToken = "lhu"

  sbToken = "sb"
  shToken = "sh"
  swToken = "sw"
  
  beqToken  = "beq"
  bneToken  = "bne" 
  bltToken  = "blt"
  bgeToken  = "bge"
  bltuToken = "bltu"
  bgeuToken = "bgeu"

  jalrToken = "jalr"
  jalToken  = "jal"

  luiToken   = "lui"
  auipcToken = "auipc"

  ecallToken  = "ecall"
  ebreakToken = "ebreak"

  beqzToken = "beqz" 
  bnezToken = "bnez"
  blezToken = "blez"
  bgezToken = "bgez"
  bltzToken = "bltz"
  bgtzToken = "bgtz"

  bgtToken  = "bgt"
  bleToken  = "ble"
  bgtuToken = "bgtu"
  bleuToken = "bleu"

  jrToken   = "jr"
  jToken    = "j"
  retToken  = "ret"
  callToken = "call"
  tailToken = "tail"

  nopToken  = "nop"
  liToken   = "li"
  mvToken   = "mv"
  notToken  = "not"
  negToken  = "neg"
  seqzToken = "seqz"
  snezToken = "snez"
  sltzToken = "sltz"
  sgtzToken = "sgtz"
  
  x0Token    = "x0"
  x1Token    = "x1"
  x2Token    = "x2"
  x3Token    = "x3"
  x4Token    = "x4"
  x5Token    = "x5"
  x6Token    = "x6"
  x7Token    = "x7"
  x8Token    = "x8"
  x9Token    = "x9"
  x10Token   = "x10"
  x11Token   = "x11"
  x12Token   = "x12"
  x13Token   = "x13"
  x14Token   = "x14"
  x15Token   = "x15"
  x16Token   = "x16"
  x17Token   = "x17"
  x18Token   = "x18"
  x19Token   = "x19"
  x20Token   = "x20"
  x21Token   = "x21"
  x22Token   = "x22"
  x23Token   = "x23"
  x24Token   = "x24"
  x25Token   = "x25"
  x26Token   = "x26"
  x27Token   = "x27"
  x28Token   = "x28"
  x29Token   = "x29"
  x30Token   = "x30"
  x31Token   = "x31"
  
  ZEROToken = "zero"
  RAToken   = "ra"
  SPToken   = "sp"
  GPToken   = "gp"
  TPToken   = "tp"
  T0Token   = "t0"
  T1Token   = "t1"
  T2Token   = "t2"
  T3Token   = "t3"
  T4Token   = "t4"
  T5Token   = "t5"
  T6Token   = "t6"
  S0Token   = "s0"
  FPToken   = "fp"
  S1Token   = "s1"
  S2Token   = "s2"
  S3Token   = "s3"
  S4Token   = "s4"
  S5Token   = "s5"
  S6Token   = "s6"
  S7Token   = "s7"
  S8Token   = "s8"
  S9Token   = "s9"
  S10Token  = "s10"
  S11Token  = "s11"
  A0Token   = "a0"
  A1Token   = "a1"
  A2Token   = "a2"
  A3Token   = "a3"
  A4Token   = "a4"
  A5Token   = "a5"
  A6Token   = "a6"
  A7Token   = "a7"

  // Directive names
  DirectiveName
  = ascizToken
  
  ascizToken= ".asciz"


  Integer "Integer"
  = _ [\+-]?[0-9]+ 
  { 
    return parseInt(text(), 10); 
  }

  ReservedWord 
  = RegisterName
  / RInstName
  / IInstName
  / LoadInstName
  / StoreInstName
  / BranchInstName
  / UpperImmInstName
  / JumpInstName
  / BPInstName
  / BPZInstName
  / MiscInstName

  Identifier
  = !ReservedWord name:IdentifierName { return name; }

  IdentifierName "identifier"
  = ![0-9][\._a-zA-Z0-9]+ 
  { 
    return {type: "IdentifierName", name:text() }; 
  }

  QuotedString "quoted string"
  = "\"" (!"\"" SourceCharacter)* "\""
  {
    return text();
  }

  __
  = (WhiteSpace / LineTerminatorSequence / Comment)*

  EOS
  = __
  / _ Comment? LineTerminatorSequence
  / _ &"}"
  / __ EOF
  
  Comment "comment"
  = ("#" / ";") (!LineTerminator SourceCharacter)* {
    return "";
  }

  SourceCharacter = .

  LineTerminatorSequence "end of line"
  = "\n"
  / "\r\n"
  / "\r"

  LineTerminator
  = [\n\r]

  EOF "End of file" = !.
  
  // Used to represent instruction registers sepparated by commas.
  ___ = _  "," _

  _  = (WhiteSpace)*

  WhiteSpace "whitespace"
  = "\t"
  / "\v"
  / "\f"
  / " "