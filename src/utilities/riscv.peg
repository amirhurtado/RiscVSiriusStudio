  {{
    var instcounter = 0;
    function getInt(val) {
      return parseInt(val,10);
    }
    
    function isImm12(val) {
      return val >= -2048 && val <= 2047;
    }
    
    function isImm20(val) {
      return val >= -524288 && val <= 524287;
    }
    
    function isValidShift(val) {
      return val >= 0 && val < 32;
    }

    function isILogical(name) {
      return (name == 'slli'|| name == 'srli' || name == 'srai');
    }
    
     function toRadix (value, radix) {
	   if (!Number.isSafeInteger(value)) {
         throw new TypeError('value must be a safe integer');
       }
       const digits = Math.ceil(64 / Math.log2(radix));
       const twosComplement = value < 0 ? BigInt(radix) ** BigInt(digits) + BigInt(value) : value;
		return twosComplement.toString(radix).padStart(digits, '0');
	}
    
    function toBinaryString(value, bitlength) {
    	return toRadix(value,2).slice(bitlength * -1);
    }

  }}
  
 Start = Program
 
  
  Program 
    = head:Statement tail:(_ Statement)* 
    {
	  const val = [head].concat(tail.map(function(elem){return elem[1];}));
      // Reset the instruction counter when finishing
      instcounter = 0;
      return val;
    }
  
  Statement 
    = inst:Instruction EOS {
      return inst;
     }
    / label:Label 
    {
    	return label;
    }
    
  Label= [a-z]+":" EOS 
  { 
  	const val = text().split(":")[0]; 
  	return {"type": "label", "name":val, "address":(instcounter)}
  }
  
  Instruction 
    = inst:RInstruction 
    {
    	const opcode = inst["opcode"]
        const rd = getInt(inst["rd"]["regenc"]);
        const funct3 = inst["funct3"];
        const rs1 = getInt(inst["rs1"]["regenc"]);
        const rs2 = getInt(inst["rs2"]["regenc"]);
        const funct7 = inst["funct7"];
    	var encoding = `${toBinaryString(funct7,5)}-${toBinaryString(rs2,5)}-${toBinaryString(rs1,5)}-${toBinaryString(funct3,3)}-${toBinaryString(rd,5)}-${opcode}`;
        inst["encoding"] = encoding;
    	return inst;
    }
    / IInstruction 
    / LInstruction
    / SInstruction
    / BInstruction
      
  RInstruction "r-type instruction"
    = name:RInstName _ rd:RegisterName __ rs1:RegisterName __ rs2:RegisterName
    {
      var funct3;
	  var funct7;
      switch (name) {
        case 'add'  : funct3 = 0; funct7 = 0;  break;
        case 'sub'  : funct3 = 0; funct7 = 32; /* 32 = 0x20 */  break;
        case 'xor'  : funct3 = 4; funct7 = 0;  break;
        case 'or'   : funct3 = 6; funct7 = 0;  break;
        case 'and'  : funct3 = 7; funct7 = 0;  break;
        case 'sll'  : funct3 = 1; funct7 = 0;  break;
        case 'srl'  : funct3 = 5; funct7 = 0;  break;
        case 'sra'  : funct3 = 5; funct7 = 32; /* 32 = 0x20 */  break;
        case 'slt'  : funct3 = 2; funct7 = 0;  break;
        case 'sltu' : funct3 = 3; funct7 = 0;  break;
      }
      return {"ïnst":instcounter++, "type":"r", "instruction": name, "rd":rd, "rs1":rs1, "rs2": rs2, "funct3": funct3, "funct7": funct7, "opcode": "0110011"};
      
    }
   
    IInstruction "i-type instruction"
    = name:IInstName _ rd:RegisterName __ rs1:RegisterName __ imm:Imm12 
    { 
      if (isILogical(name) && !isValidShift(imm)) {
      	return error("Expecting valid shift ammount. Got " + imm);
      }
      var funct3;
	  var funct7 = 0;
      switch (name) {
        case 'addi'  : funct3 = 0; break;
        case 'xori'  : funct3 = 4; break;
        case 'ori'   : funct3 = 6; break;
        case 'andi'  : funct3 = 7; break;
        case 'slli'  : funct3 = 1; funct7 = 0;  break;
        case 'srli'  : funct3 = 5; funct7 = 0;  break;
        case 'srai'  : funct3 = 3; funct7 = 32;  /* 32 = 0x20 */ break;
        case 'slti'  : funct3 = 2; break;
        case 'sltiu' : funct3 = 3; break;

      }
      return {"ïnst":instcounter++, "type":"i", "instruction": name, "rd":rd, "rs1":rs1, "imm12": imm, "funct3": funct3, "funct7": funct7, "opcode": "0010011"};
    }

    LInstruction "load instruction"
      = name:LoadInstName _ rd:RegisterName __ offset:Imm12 _"("_ rs1:RegisterName _")" 
      { 
        var funct3;
        switch (name) {
          case 'lb'  : funct3 = 0; break;
          case 'lh'  : funct3 = 1; break;
          case 'lw'  : funct3 = 2; break;
          case 'lbu' : funct3 = 4; break;
          case 'lhu' : funct3 = 5; break;
        }
        return {"ïnst":instcounter++, "type":"i", "instruction": name, "rd":rd, "rs1":rs1, "offset": offset, "funct3": funct3, "opcode": "0000011"};
      }
    
    SInstruction "store instruction"
    = name:StoreInstName _ rs2:RegisterName __ offset:Imm12 _"("_ rs1:RegisterName _")" 
    { 
      var funct3;
      switch (name) {
        case 'sb'  : funct3 = 0; break;
        case 'sh'  : funct3 = 1; break;
        case 'sw'  : funct3 = 2; break;
      }
      return {"ïnst":instcounter++, "type":"s", "instruction": name, "rs1":rs1, "rs2":rs2, "offset": offset, "funct3": funct3, "opcode": "0100011"};
    }

    BInstruction "branch instruction"
    = name:BranchInstName _ rs1:RegisterName __ rs2:RegisterName __ offset:Imm12  
    { 
      var funct3;
      switch (name) {
        case 'beq'   : funct3 = 0; break;
        case 'bne'   : funct3 = 1; break;
        case 'blt'   : funct3 = 4; break;
        case 'bge'   : funct3 = 5; break;
        case 'bltu'  : funct3 = 6; break;
        case 'bgeu'  : funct3 = 7; break;

      }
      return {"ïnst":instcounter++, "type":"b", "instruction": name, "rs1":rs1, "rs2":rs2, "offset": offset, "funct3": funct3, "opcode": "1100011"};
    }

    JInstruction "jump instruction"
    = name:jalToken _ rd:RegisterName __ offset:Imm20  
    { 
      return {"ïnst":instcounter++, "type":"j", "instruction": name, "rd":rd, "offset": offset, "opcode": "1101111"};
    }
    / name:jalrToken _ rd:RegisterName __ offset:Imm12 "(" _ rs1:RegisterName _ ")" 
    {
      return {"ïnst":instcounter++, "type":"i", "instruction": name, "rd":rd, "rs1":rs1, "imm12": imm, "funct3": 0, "funct7": 0, "opcode": "1100111"};
    }

  Imm12
  = val:Integer
    {
    	const v = getInt(val);
        if (isImm12(v))
        	return v;
        return error("Expecting 12 bit representable value. Got " + v, location());
	}
  
  Imm20
  = val:Integer
    {
    	const v = getInt(val);
        if (isImm20(v))
        	return v;
        return error("Expecting 20 bit representable value. Got " + v, location());
	}


  InstName "instruction name"
    = RInstName
    / IInstName 
  
  BranchInstName "branch type instruction name"
	= beqToken
    / bneToken
    / bltToken
    / bgeToken
    / bltuToken
    / bgeuToken

  StoreInstName "store type instruction name"
	= sbToken
    / shToken
    / swToken

  LoadInstName "load type instruction name"
	= lbToken
    / lhToken
    / lwToken
    / lbuToken
    / lhuToken
    
  RInstName "r-type instruction name"
    = addToken
    / subToken
    / xorToken
    / orToken
    / andToken
    / sllToken
    / srlToken
    / sraToken
    / sltToken
    / sltuToken
  
  IInstName "i-type instruction name"
    = addiToken
    / xoriToken
    / oriToken
    / andiToken
    / slliToken
    / srliToken
    / sraiToken
    / sltiToken
    / sltiuToken
    
  RegisterName "register name" 
    = reg:ABIRegister
    {
    	var r = reg;
        r["regenc"] = reg["regeq"].slice(1);
    	return r;
    }
    / reg:Register 
    {
      const v = reg.slice(1);
      return {"regname": reg, "regeq": reg, "regenc":v};
    }


  Register "register"
    = // remember pegg format!
      x10Token
    / x11Token
    / x12Token
    / x13Token
    / x14Token
    / x15Token
    / x16Token
    / x17Token
    / x18Token
    / x19Token
    / x20Token
    / x21Token
    / x22Token
    / x23Token
    / x24Token
    / x25Token
    / x26Token
    / x27Token
    / x28Token
    / x29Token
    / x30Token
    / x31Token
    / x0Token
    / x1Token
    / x2Token
    / x3Token
    / x4Token
    / x5Token
    / x6Token
    / x7Token
    / x8Token
    / x9Token

  

  ABIRegister "abiregister"
    = reg:ZEROToken {return {"regname": reg, "regeq": "x0"};}
    / reg:RAToken   {return {"regname": reg, "regeq": "x1"};}
    / reg:SPToken   {return {"regname": reg, "regeq": "x2"};}
  	/  reg:GPToken  {return {"regname": reg, "regeq": "x3"};} 
  	/  reg:TPToken  {return {"regname": reg, "regeq": "x4"};}
  	/  reg:T0Token  {return {"regname": reg, "regeq": "x5"};}
  	/  reg:T1Token  {return {"regname": reg, "regeq": "x6"};}  
  	/  reg:T2Token  {return {"regname": reg, "regeq": "x7"};}  
  	/  reg:T3Token  {return {"regname": reg, "regeq": "x28"};}  
  	/  reg:T4Token  {return {"regname": reg, "regeq": "x29"};} 
  	/  reg:T5Token  {return {"regname": reg, "regeq": "x30"};}  
  	/  reg:T6Token  {return {"regname": reg, "regeq": "x31"};}  
  	/  reg:S0Token  {return {"regname": reg, "regeq": "x8"};}
  	/  reg:FPToken  {return {"regname": reg, "regeq": "x8"};}  
  	/  reg:S1Token  {return {"regname": reg, "regeq": "x9"};}  
  	/  reg:S2Token  {return {"regname": reg, "regeq": "x18"};}  
  	/  reg:S3Token  {return {"regname": reg, "regeq": "x19"};}
  	/  reg:S4Token  {return {"regname": reg, "regeq": "x20"};} 
   	/  reg:S5Token   {return {"regname": reg, "regeq": "x21"};} 
  	/  reg:S6Token   {return {"regname": reg, "regeq": "x22"};} 
  	/  reg:S7Token   {return {"regname": reg, "regeq": "x23"};} 
  	/  reg:S8Token   {return {"regname": reg, "regeq": "x24"};} 
  	/  reg:S9Token   {return {"regname": reg, "regeq": "x25"};} 
  	/  reg:S10Token   {return {"regname": reg, "regeq": "x26"};} 
  	/  reg:S11Token   {return {"regname": reg, "regeq": "x27"};} 
  	/  reg:A0Token   {return {"regname": reg, "regeq": "x10"};} 
  	/  reg:A1Token   {return {"regname": reg, "regeq": "x11"};} 
  	/  reg:A2Token   {return {"regname": reg, "regeq": "x12"};} 
  	/  reg:A3Token   {return {"regname": reg, "regeq": "x13"};} 
  	/  reg:A4Token   {return {"regname": reg, "regeq": "x14"};} 
  	/  reg:A5Token   {return {"regname": reg, "regeq": "x15"};} 
  	/  reg:A6Token   {return {"regname": reg, "regeq": "x16"};} 
  	/  reg:A7Token   {return {"regname": reg, "regeq": "x17"};} 


  
  Comment "comment"
    = "//" (!LineTerminator .)* {return text();}
    / ";" (!LineTerminator .)*  {return text();}
    / "#" (!LineTerminator .)*  {return text();}
  
  addToken  = "add"
  subToken  = "sub"
  xorToken  = "xor"
  orToken  = "xor"
  andToken  = "and"
  sllToken  = "sll"
  srlToken  = "srl"
  sraToken  = "sra"
  sltToken  = "slt"
  sltuToken = "sltu"
  
  addiToken  = "addi"
  xoriToken  = "xori"
  oriToken   = "ori"
  andiToken  = "andi"
  slliToken  = "slli"
  srliToken  = "srli"
  sraiToken  = "srai"
  sltiToken  = "slti"
  sltiuToken = "sltiu"
  
  lbToken  = "lb"
  lhToken  = "lh"
  lwToken  = "lw"
  lbuToken = "lbu"
  lhuToken = "lhu"

  sbToken = "sb"
  shToken = "sh"
  swToken = "sw"
  
  beqToken  = "beq"
  bneToken  = "bne" 
  bltToken  = "blt"
  bgeToken  = "bge"
  bltuToken = "bltu"
  bgeuToken = "bgeu"

  jalToken  = "jal"
  jalrToken = "jalr"

  luiToken   = "lui"
  auipcToken = "auipc"

  ecallToken  = "ecall"
  ebreakToken = "ebreak"
  
  x0Token   = "x0"
  x1Token   = "x1"
  x2Token   = "x2"
  x3Token   = "x3"
  x4Token   = "x4"
  x5Token   = "x5"
  x6Token   = "x6"
  x7Token   = "x7"
  x8Token   = "x8"
  x9Token   = "x9"
  x10Token   = "x10"
  x11Token   = "x11"
  x12Token   = "x12"
  x13Token   = "x13"
  x14Token   = "x14"
  x15Token   = "x15"
  x16Token   = "x16"
  x17Token   = "x17"
  x18Token   = "x18"
  x19Token   = "x19"
  x20Token   = "x20"
  x21Token   = "x21"
  x22Token   = "x22"
  x23Token   = "x23"
  x24Token   = "x24"
  x25Token   = "x25"
  x26Token   = "x26"
  x27Token   = "x27"
  x28Token   = "x28"
  x29Token   = "x29"
  x30Token   = "x30"
  x31Token   = "x31"
  
  ZEROToken = "zero"
  RAToken   = "ra"
  SPToken   = "sp"
  GPToken   = "gp"
  TPToken   = "tp"
  T0Token   = "t0"
  T1Token   = "t1"
  T2Token   = "t2"
  T3Token   = "t3"
  T4Token   = "t4"
  T5Token   = "t5"
  T6Token   = "t6"
  S0Token   = "s0"
  FPToken   = "fp"
  S1Token   = "s1"
  S2Token   = "s2"
  S3Token   = "s3"
  S4Token   = "s4"
  S5Token   = "s5"
  S6Token   = "s6"
  S7Token   = "s7"
  S8Token   = "s8"
  S9Token   = "s9"
  S10Token   = "s10"
  S11Token   = "s11"
  A0Token   = "a0"
  A1Token   = "a1"
  A2Token   = "a2"
  A3Token   = "a3"
  A4Token   = "a4"
  A5Token   = "a5"
  A6Token   = "a6"
  A7Token   = "a7"

  Integer "integer"
  = _ [\+-]?[0-9]+ 
  { 
    return parseInt(text(), 10); 
  }

  EOS
    = _ x:Comment? (LineTerminator / EOF) {return null;}
    / EOF
  
  LineTerminator
    = "\n"
    / "\r\n"
    
  EOF
    = !.
  __
    = _  "," _
 
 WhiteSpace "whitespace"
   = "\t"
   / " "
  _ 
  = (WhiteSpace)*